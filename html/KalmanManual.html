
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Comparison of four different types of filters to find orientation</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-08-14"><meta name="DC.source" content="KalmanManual.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Comparison of four different types of filters to find orientation</h1><!--introduction--><p>In this tutorial, we will learn how to calculate the orientation of our mobile phone by using 4 different filters.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Read log data</a></li><li><a href="#2">Extract out numerical entries of data into an array</a></li><li><a href="#3">1) Accelerometer only</a></li><li><a href="#4">2) Gyroscope only</a></li><li><a href="#5">3) Complimentary Filter</a></li><li><a href="#6">4) Kalman Filter</a></li><li><a href="#7">Convert all estimates to degrees</a></li><li><a href="#8">Plots</a></li></ul></div><h2 id="1">Read log data</h2><p>First, we read out log file and store the variables in Matlab workspace</p><pre class="codeinput">read_log_script
<span class="comment">% On the workspace window, you will see gyro_ts and acc_ts. Those are the</span>
<span class="comment">% timeseries (a time-related version of arrays). Those two variables will</span>
<span class="comment">% be our main data sets.</span>
</pre><pre class="codeoutput"> Data from sensorLog_2pitch.txtsaved
</pre><h2 id="2">Extract out numerical entries of data into an array</h2><pre class="codeinput">Gx = gyro_ts.Data(:,1);
Gy = gyro_ts.Data(:,2);
Gz = gyro_ts.Data(:,3);

Ax = acc_ts.Data(:,1);
Ay = acc_ts.Data(:,2);
Az = acc_ts.Data(:,3);

<span class="comment">% Our mobile app logs the data in each 10ms.</span>
dt = 0.01;

<span class="comment">% Our data lenght is the shortest data set either accelerometer or</span>
<span class="comment">% gyroscope.</span>
number_of_data = min(length(gyro_ts.Data),length(acc_ts.Data));
</pre><h2 id="3">1) Accelerometer only</h2><p>This method is also known as tilt calculation. We make this calculation based on the gravity vector and its components on each accelerometer axes. This technique is only applicable where the linear acceleration of the body is very low.</p><pre class="codeinput">phi_hat_acc   = atan2(Ay, sqrt(Ax .^ 2 + Az .^ 2));
theta_hat_acc = atan2(-Ax, sqrt(Ay .^ 2 + Az .^ 2));
</pre><h2 id="4">2) Gyroscope only</h2><p>This method is based on integration the velocity to find the position as we all do in highschool. It works okay for short time frames. However, in longer period there will be accumulation during the integration process - which is also known as drift error.</p><pre class="codeinput">phi_hat_gyr   = zeros(1, length(gyro_ts));
theta_hat_gyr = zeros(1, length(gyro_ts));

<span class="keyword">for</span> i = 2:number_of_data
   p = Gx(i);
   q = Gy(i);
   r = Gz(i);

   phi_hat   = phi_hat_gyr(i - 1);
   theta_hat = theta_hat_gyr(i - 1);

   phi_hat_gyr(i)   = phi_hat   + dt * (p + sin(phi_hat) * tan(theta_hat) * q + cos(phi_hat) * tan(theta_hat) * r);
   theta_hat_gyr(i) = theta_hat + dt * (cos(phi_hat) * q - sin(phi_hat) * r);
<span class="keyword">end</span>
</pre><h2 id="5">3) Complimentary Filter</h2><p>Complementary filter is a combination of a low-pass and a high-pass filter. Idea behind complementary filter is to take slow moving signals from accelerometer and fast moving signals from a gyroscope and combine them. Accelerometer gives a good indicator of orientation in static conditions. Gyroscope gives a good indicator of tilt in dynamic conditions.</p><pre class="codeinput"><span class="comment">% alpha value is related the cut-off frequency of the filters.</span>
alpha = 0.1;

phi_hat_complimentary   = zeros(1, length(gyro_ts));
theta_hat_complimentary = zeros(1, length(gyro_ts));

<span class="keyword">for</span> i=2:number_of_data
    p = Gx(i);
    q = Gy(i);
    r = Gz(i);

    phi_hat   = phi_hat_complimentary(i - 1);
    theta_hat = theta_hat_complimentary(i - 1);

    phi_hat_gyr_comp   = phi_hat   + dt * (p + sin(phi_hat) * tan(theta_hat) * q + cos(phi_hat) * tan(theta_hat) * r);
    theta_hat_gyr_comp = theta_hat + dt * (cos(phi_hat) * q - sin(phi_hat) * r);

    phi_hat_complimentary(i)   = (1 - alpha) * phi_hat_gyr_comp   + alpha * phi_hat_acc(i);
    theta_hat_complimentary(i) = (1 - alpha) * theta_hat_gyr_comp + alpha * theta_hat_acc(i);
<span class="keyword">end</span>
</pre><h2 id="6">4) Kalman Filter</h2><p>Kalman filter is an estimater (and observer). Using the system model, it reduces the estimation error in every iteration. It consists two parts; prediction and correction.</p><pre class="codeinput">A = [1 -dt 0 0; 0 1 0 0; 0 0 1 -dt; 0 0 0 1];
B = [dt 0 0 0; 0 0 dt 0]';
C = [1 0 0 0; 0 0 1 0];
P = eye(4);
Q = eye(4) * 0.01;
R = eye(2) * 10;
state_estimate = [0 0 0 0]';

phi_hat_kalman    = zeros(1, number_of_data);
bias_phi_kalman   = zeros(1, number_of_data);
theta_hat_kalman  = zeros(1, number_of_data);
bias_theta_kalman = zeros(1, number_of_data);

<span class="keyword">for</span> i=2:number_of_data

    p = Gx(i);
    q = Gy(i);
    r = Gz(i);

    phi_hat   = phi_hat_kalman(i - 1);
    theta_hat = theta_hat_kalman(i - 1);

    phi_dot   = p + sin(phi_hat) * tan(theta_hat) * q + cos(phi_hat) * tan(theta_hat) * r;
    theta_dot = cos(phi_hat) * q - sin(phi_hat) * r;

    <span class="comment">% Predict</span>
    state_estimate = A * state_estimate + B * [phi_dot, theta_dot]';
    P = A * P * A' + Q;

    <span class="comment">% Update (Correct)</span>
    measurement = [phi_hat_acc(i) theta_hat_acc(i)]';
    y_tilde = measurement - C * state_estimate;
    S = R + C * P * C';
    K = P * C' * (S^-1);
    state_estimate = state_estimate + K * y_tilde;
    P = (eye(4) - K * C) * P;

    phi_hat_kalman(i)    = state_estimate(1);
    bias_phi_kalman(i)   = state_estimate(2);
    theta_hat_kalman(i)  = state_estimate(3);
    bias_theta_kalman(i) = state_estimate(4);

<span class="keyword">end</span>
</pre><h2 id="7">Convert all estimates to degrees</h2><pre class="codeinput">phi_hat_acc = phi_hat_acc * 180.0 / pi; theta_hat_acc = theta_hat_acc * 180.0 / pi;
phi_hat_gyr = phi_hat_gyr * 180.0 / pi; theta_hat_gyr = theta_hat_gyr * 180.0 / pi;
phi_hat_complimentary = phi_hat_complimentary * 180.0 / pi; theta_hat_complimentary = theta_hat_complimentary * 180.0 / pi;
phi_hat_kalman = phi_hat_kalman * 180.0 / pi; theta_hat_kalman = theta_hat_kalman * 180.0 / pi;
</pre><h2 id="8">Plots</h2><pre class="codeinput">t = acc_ts.Time;
plot(t, phi_hat_complimentary);
hold <span class="string">on</span>;
plot(t, phi_hat_acc);
plot(t, phi_hat_gyr);
plot(t, phi_hat_kalman);
legend(<span class="string">'Complimentary'</span>, <span class="string">'Accelerometer'</span>, <span class="string">'Gyro'</span>, <span class="string">'Kalman'</span>);
xlabel(<span class="string">'Time (s)'</span>);
ylabel(<span class="string">'Angle (Degrees)'</span>);
title(<span class="string">'Roll'</span>);
xlim([0 t(end)])

figure(2);
plot(t, theta_hat_complimentary);
hold <span class="string">on</span>;
plot(t, theta_hat_acc);
plot(t, theta_hat_gyr);
plot(t, theta_hat_kalman);
legend(<span class="string">'Complementary'</span>, <span class="string">'Accelerometer'</span>, <span class="string">'Gyro'</span>, <span class="string">'Kalman'</span>);
xlabel(<span class="string">'Time (s)'</span>);
ylabel(<span class="string">'Angle (Degrees)'</span>);
title(<span class="string">'Pitch'</span>);
xlim([0 t(end)])
</pre><img vspace="5" hspace="5" src="KalmanManual_01.png" alt=""> <img vspace="5" hspace="5" src="KalmanManual_02.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Comparison of four different types of filters to find orientation
% In this tutorial, we will learn how to calculate the orientation of our
% mobile phone by using 4 different filters.

%% Read log data
% First, we read out log file and store the variables in Matlab workspace
read_log_script
% On the workspace window, you will see gyro_ts and acc_ts. Those are the
% timeseries (a time-related version of arrays). Those two variables will
% be our main data sets.

%% Extract out numerical entries of data into an array
Gx = gyro_ts.Data(:,1);
Gy = gyro_ts.Data(:,2);
Gz = gyro_ts.Data(:,3);

Ax = acc_ts.Data(:,1);
Ay = acc_ts.Data(:,2);
Az = acc_ts.Data(:,3);

% Our mobile app logs the data in each 10ms.
dt = 0.01;

% Our data lenght is the shortest data set either accelerometer or
% gyroscope.
number_of_data = min(length(gyro_ts.Data),length(acc_ts.Data));

%% 1) Accelerometer only
% This method is also known as tilt calculation. We make this calculation
% based on the gravity vector and its components on each accelerometer
% axes. This technique is only applicable where the linear acceleration of
% the body is very low.
phi_hat_acc   = atan2(Ay, sqrt(Ax .^ 2 + Az .^ 2));
theta_hat_acc = atan2(-Ax, sqrt(Ay .^ 2 + Az .^ 2));

%% 2) Gyroscope only
% This method is based on integration the velocity to find the position as
% we all do in highschool. It works okay for short time frames. However, in
% longer period there will be accumulation during the integration process -
% which is also known as drift error.
phi_hat_gyr   = zeros(1, length(gyro_ts));
theta_hat_gyr = zeros(1, length(gyro_ts));

for i = 2:number_of_data
   p = Gx(i);
   q = Gy(i);
   r = Gz(i);
   
   phi_hat   = phi_hat_gyr(i - 1);
   theta_hat = theta_hat_gyr(i - 1);
    
   phi_hat_gyr(i)   = phi_hat   + dt * (p + sin(phi_hat) * tan(theta_hat) * q + cos(phi_hat) * tan(theta_hat) * r);
   theta_hat_gyr(i) = theta_hat + dt * (cos(phi_hat) * q - sin(phi_hat) * r);
end

%% 3) Complimentary Filter
% Complementary filter is a combination of a low-pass and a high-pass
% filter. Idea behind complementary filter is to take slow moving signals from
% accelerometer and fast moving signals from a gyroscope and combine them.
% Accelerometer gives a good indicator of orientation in static conditions.
% Gyroscope gives a good indicator of tilt in dynamic conditions.

% alpha value is related the cut-off frequency of the filters.
alpha = 0.1;

phi_hat_complimentary   = zeros(1, length(gyro_ts));
theta_hat_complimentary = zeros(1, length(gyro_ts));

for i=2:number_of_data
    p = Gx(i);
    q = Gy(i);
    r = Gz(i);
   
    phi_hat   = phi_hat_complimentary(i - 1);
    theta_hat = theta_hat_complimentary(i - 1);
    
    phi_hat_gyr_comp   = phi_hat   + dt * (p + sin(phi_hat) * tan(theta_hat) * q + cos(phi_hat) * tan(theta_hat) * r);
    theta_hat_gyr_comp = theta_hat + dt * (cos(phi_hat) * q - sin(phi_hat) * r);
       
    phi_hat_complimentary(i)   = (1 - alpha) * phi_hat_gyr_comp   + alpha * phi_hat_acc(i);
    theta_hat_complimentary(i) = (1 - alpha) * theta_hat_gyr_comp + alpha * theta_hat_acc(i);    
end

%% 4) Kalman Filter
% Kalman filter is an estimater (and observer). Using the system model, it
% reduces the estimation error in every iteration. It consists two parts;
% prediction and correction.
A = [1 -dt 0 0; 0 1 0 0; 0 0 1 -dt; 0 0 0 1];
B = [dt 0 0 0; 0 0 dt 0]';
C = [1 0 0 0; 0 0 1 0];
P = eye(4);
Q = eye(4) * 0.01;
R = eye(2) * 10;
state_estimate = [0 0 0 0]';

phi_hat_kalman    = zeros(1, number_of_data);
bias_phi_kalman   = zeros(1, number_of_data);
theta_hat_kalman  = zeros(1, number_of_data);
bias_theta_kalman = zeros(1, number_of_data);

for i=2:number_of_data
    
    p = Gx(i);
    q = Gy(i);
    r = Gz(i);
   
    phi_hat   = phi_hat_kalman(i - 1);
    theta_hat = theta_hat_kalman(i - 1);
    
    phi_dot   = p + sin(phi_hat) * tan(theta_hat) * q + cos(phi_hat) * tan(theta_hat) * r;
    theta_dot = cos(phi_hat) * q - sin(phi_hat) * r;
          
    % Predict
    state_estimate = A * state_estimate + B * [phi_dot, theta_dot]';
    P = A * P * A' + Q;
    
    % Update (Correct)
    measurement = [phi_hat_acc(i) theta_hat_acc(i)]';
    y_tilde = measurement - C * state_estimate;
    S = R + C * P * C';
    K = P * C' * (S^-1);
    state_estimate = state_estimate + K * y_tilde;
    P = (eye(4) - K * C) * P;
    
    phi_hat_kalman(i)    = state_estimate(1);
    bias_phi_kalman(i)   = state_estimate(2);
    theta_hat_kalman(i)  = state_estimate(3);
    bias_theta_kalman(i) = state_estimate(4);
    
end

%% Convert all estimates to degrees
phi_hat_acc = phi_hat_acc * 180.0 / pi; theta_hat_acc = theta_hat_acc * 180.0 / pi;
phi_hat_gyr = phi_hat_gyr * 180.0 / pi; theta_hat_gyr = theta_hat_gyr * 180.0 / pi;
phi_hat_complimentary = phi_hat_complimentary * 180.0 / pi; theta_hat_complimentary = theta_hat_complimentary * 180.0 / pi;
phi_hat_kalman = phi_hat_kalman * 180.0 / pi; theta_hat_kalman = theta_hat_kalman * 180.0 / pi;

%% Plots
t = acc_ts.Time;
plot(t, phi_hat_complimentary);
hold on;
plot(t, phi_hat_acc);
plot(t, phi_hat_gyr);
plot(t, phi_hat_kalman);
legend('Complimentary', 'Accelerometer', 'Gyro', 'Kalman');
xlabel('Time (s)');
ylabel('Angle (Degrees)');
title('Roll');
xlim([0 t(end)])

figure(2);
plot(t, theta_hat_complimentary);
hold on;
plot(t, theta_hat_acc);
plot(t, theta_hat_gyr);
plot(t, theta_hat_kalman);
legend('Complementary', 'Accelerometer', 'Gyro', 'Kalman');
xlabel('Time (s)');
ylabel('Angle (Degrees)');
title('Pitch');
xlim([0 t(end)])
##### SOURCE END #####
--></body></html>